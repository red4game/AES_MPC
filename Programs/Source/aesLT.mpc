import math
import copy
from Compiler.library import for_range_opt

from Compiler.types import cgf2n,sgf2n

 
program.use_edabit(True)
nparallel = 1
noutput = 1
nthreads = 1


class boxLT():
    def __init__(self):
        sbox_raw = [
            0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
        ]
        self.sbox = Array(len(sbox_raw), cgf2n)
        #self.obox = OptimalORAM(len(sbox_raw),sgf2n)
        for idx in range(len(sbox_raw)):
            self.sbox[idx] = cgf2n(sbox_raw[idx],size=nparallel)
            #self.obox[idx] = sgf2n(sbox_raw[idx],size=nparallel)
        

        sboxInv_raw = [
                0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
                0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
                0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
                0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
                0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
                0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
                0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
                0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
                0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
                0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
                0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
                0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
                0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
                0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
                0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
                0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
        ]
        self.sboxInv = Array(len(sboxInv_raw), cgf2n)
        for idx in range(len(sboxInv_raw)):
            self.sboxInv[idx] = cgf2n(sboxInv_raw[idx],size=nparallel)
        rcon_raw = [
                0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
                0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
                0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
                0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
                0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
                0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
                0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
                0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
                0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
                0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
                0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
                0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
                0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
                0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
                0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
                0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb
        ]
        self.rcon = Array(len(rcon_raw), cgf2n)
        for idx in range(len(rcon_raw)):
            self.rcon[idx] = cgf2n(rcon_raw[idx],size=nparallel)

        

box = boxLT()

def rotate(word, n):
    #positive to rotate to left and negative to rotate right 
    nword = Array(len(word),sgf2n)
    @for_range_opt(abs(n))
    def _nah(i):
        nword[(len(word)-n+i)%len(word)] = word[i]
    @for_range_opt(len(word)-n)
    def _btw(j):
        nword[j%len(word)] = word[(j+n)] 
    return nword

def expandAESKey(cipherKey, Nr = 14, Nb = 4, Nk = 8):
    round_key = Array(240,sgf2n)
    temp = Array(4,sgf2n)

    @for_range_opt([Nk,4])
    def _whatever(i,j):
        round_key[(4*i)+j] = cipherKey[(4*i)+j]

    @for_range_opt(Nb * (Nr + 1)-Nk)
    def _perhaps(i):
        @for_range_opt(4)
        def _ohno(j):
            temp[j] = round_key[(i-1+Nk) * 4 + j]
        if i % Nk == 0:
            #rotate the 4 bytes word to the left
            temp.assign(rotate(temp,1))

            #now substitute word
            temp[0] = boxEvaluation(box.sbox,temp[0])
            temp[1] = boxEvaluation(box.sbox,temp[1])
            temp[2] = boxEvaluation(box.sbox,temp[2])
            temp[3] = boxEvaluation(box.sbox,temp[3])

            temp[0] = temp[0] ^ box.rcon[((i+Nk)//Nk)]

        # since we're using a 256-bit key -> add an extra sbox transform
        if i % Nk == 4:
            temp[0] = boxEvaluation(box.sbox,temp[0])
            temp[1] = boxEvaluation(box.sbox,temp[1])
            temp[2] = boxEvaluation(box.sbox,temp[2])
            temp[3] = boxEvaluation(box.sbox,temp[3])

        @for_range_opt(4)
        def _idk(j):
            round_key[4 * (i+Nk) + j] = round_key[4 * i + j] ^ temp[j]
    return round_key

    #Nr -> The number of rounds in AES Cipher.
    #Nb -> The number of columns of the AES state
    #Nk -> The number of words of a AES key 

def demux(s):
    l = len(s)
    p = [1-s[0],s[0]]
    for j in range(1,l):
        t=[]
        for bit in p:
            t.append(bit*s[j])
        addLeft = [*([sgf2n(0,size=nparallel)]*(2**j)),*t] #peut être changer le type du 0 pour match cgf2n ou sgf2n
        addRight = []
        for (bp,bt) in zip(p, t):
            addRight.append(bp-bt) # shouldn't be negative by definition of t array
        addRight = [*addRight,*([sgf2n(0,size=nparallel)]*(2**j))]
        tempP = []
        for (bl,br) in zip(addLeft, addRight):
            tempP.append((bl+br))
        p = tempP
    
    # normally we should had do P = (B0,...,Bu-1) with Bi in F2^k and then have (S'ki,...,S'ki+k-1) with bitdec(Bi) but we already have a bit dec so i will only return P
    return p #P is now in F2^(2^(j+1)) = F2^n

def generateSSTable(T):
    s = Array.create_from(sgf2n.get_random_input_mask_for(0)[0].bit_decompose()[0:int(math.log2(len(T)))])
    
    #verifiy where we send the private mask (for me we send to the person that has the index and will receive the tab)
    #print_ln("longueur s : %s",len(s))
    #s.print_reveal_nested(end=' ')
    sp = Array.create_from(demux(s))
    #sp.print_reveal_nested(end=' ')
    
    #print_ln("longueur T : %s",len(T))
    #print_ln("longueur sp : %s",len(sp))
    Table = Array(2**(len(s)),sgf2n)
    Table.assign_all(sgf2n(0))
    @for_range_opt([2**(len(s)),2**(len(s))])
    def _(i,j):
        Table[i] += T[i^j]*sp[j]
    return (sgf2n.bit_compose(s),Table)


class globalVars():
    generated= MemValue(0)
    s = MemValue(sgf2n(0))
    Table = Array(256,sgf2n)
    prevT = MemValue(0)
#verify why table[h] give me the other value
def boxEvaluation(T,x):
    #partie faite en sorte pour faire ne sorte que si jamais on a déjà généra avant avec le même tableau on garde notre tabe pour des simplicité de calcul
    
    if (globalVars.generated.read()==0):
        (st,Tablet) = generateSSTable(T)
        globalVars.s.write(st)
        globalVars.Table.assign(Tablet)
        globalVars.generated.write(1)
        globalVars.prevT.write(T.address)
    else: #we can't make A and B
        if (globalVars.prevT.read()!=T.address):
            (st,Tablet) = generateSSTable(T)
            globalVars.s.write(st)
            globalVars.Table.assign(Tablet)
            globalVars.prevT.write(T.address)

        
    #print_ln("my S %s",s.reveal())
    h = regint((x^globalVars.s.read()).reveal())
    
    """
    print_ln("python loop")
    for i in range(len(Table)):
        print_ln("%s;%s;%s",hex(i),h,i==h)
        if (i == h):
            print_ln("found at %s",h)
        print_ln("%s : %s",i,Table[cgf2n(i)].reveal())
    print_ln("their loop")
    @for_range_opt(len(Table))
    def _mouais(i): 
        print_ln("%s;%s;%s",i,h,cgf2n(i)==h)
        if (cgf2n(i) == h):
            print_ln("found at %s",h)
        print_ln("%s : %s",i,Table.get(i).reveal())
    #if i do not misunderstand we can give index only with public (regint/cint/int/slice) but not cgf2n and if we give his cgf2n he has a pretty bad guess
    
    #print_ln("my X %s",x.reveal())
    #print_ln("this is my h %s",h)
    #print_ln("this is my value %s",Table[h].reveal()) # completely useless because random error
    #print_ln("this is my result %s",res)
    """

    
    return globalVars.Table[h].reveal() # corresponds to T(x^s^s) = T(x) without knowing x because its sgf2n and 

#can i use oram module to compute already with a secret index ? 





def subBytes(state):
    @for_range_opt(len(state))
    def _(i):
        state[i] = boxEvaluation(box.sbox,state[i])
    print_ln("after sub bytes")
    state.print_reveal_nested(end="\n")
    

def invSubBytes(state):
    @for_range_opt(len(state))
    def _(i):
        state[i] = boxEvaluation(box.sboxInv,state[i])
    print_ln("after inverse sub bytes")
    state.print_reveal_nested(end="\n")

def addRoundKey(state,round_key):
    @for_range_opt(len(state))
    def _(i):
        state[i] = state[i] ^ round_key[i]
    print_ln("after adding round key ")
    state.print_reveal_nested(end="\n")

"""
def gf_mul(ap, bp):
    p=MemValue(0)
    a=MemValue(ap)
    b=MemValue(bp)
    @for_range_opt(8)
    def _whyyy(i):
        #print_ln("a:%s & b:%s",a[0].reveal(),b[0].reveal())
        if ((b.read() & 1) == 1).reveal():
            p.write(p.read()^a.read())
        hiBitSet = (a.read() & 0x80) != 0
        a.write(a.read()<<1)
        if hiBitSet.reveal():
            a.write(a.read()^0x1b)
        b.write(b.read().right_shift(1))
    return sgf2n.bit_compose(p.read().bit_decompose()[0:8])
"""

#https://core.ac.uk/download/pdf/82642844.pdf
@vectorize
def ApplyClearEmbedding(x):
    in_bytes = x.bit_decompose(8)

    out_bytes = [cgf2n(0) for _ in range(8)]

    out_bytes[0] = sum(in_bytes[0:8])
    out_bytes[1] = sum(in_bytes[idx] for idx in range(1, 8, 2))
    out_bytes[2] = in_bytes[2] + in_bytes[3] + in_bytes[6] + in_bytes[7]
    out_bytes[3] = in_bytes[3] + in_bytes[7]
    out_bytes[4] = in_bytes[4] + in_bytes[5] + in_bytes[6] + in_bytes[7]
    out_bytes[5] = in_bytes[5] + in_bytes[7]
    out_bytes[6] = in_bytes[6] + in_bytes[7]
    out_bytes[7] = in_bytes[7]
    
    return cgf2n.bit_compose(out_bytes)

@vectorize
def ApplySecretEmbedding(x):
    in_bytes = x.bit_decompose(8)

    out_bytes = [sgf2n(0) for _ in range(8)]

    out_bytes[0] = sum(in_bytes[0:8])
    out_bytes[1] = sum(in_bytes[idx] for idx in range(1, 8, 2))
    out_bytes[2] = in_bytes[2] + in_bytes[3] + in_bytes[6] + in_bytes[7]
    out_bytes[3] = in_bytes[3] + in_bytes[7]
    out_bytes[4] = in_bytes[4] + in_bytes[5] + in_bytes[6] + in_bytes[7]
    out_bytes[5] = in_bytes[5] + in_bytes[7]
    out_bytes[6] = in_bytes[6] + in_bytes[7]
    out_bytes[7] = in_bytes[7]
    
    return sgf2n.bit_compose(out_bytes)

@vectorize
def ApplyClearInverseEmbedding(x):
    in_bytes = x.bit_decompose(40)

    out_bytes = [cgf2n(0) for _ in range(8)]

    out_bytes[7] = in_bytes[7]
    out_bytes[6] = in_bytes[6] + out_bytes[7]
    out_bytes[5] = in_bytes[5] + out_bytes[7]
    out_bytes[4] = in_bytes[4] + out_bytes[5] + out_bytes[6] + out_bytes[7]
    out_bytes[3] = in_bytes[3] + out_bytes[7]
    out_bytes[2] = in_bytes[2] + out_bytes[3] + out_bytes[6] + out_bytes[7]
    out_bytes[1] = in_bytes[1] +  out_bytes[3] + out_bytes[5] + out_bytes[7]
    out_bytes[0] = in_bytes[0] + sum(out_bytes[1:8])

    return cgf2n.bit_compose(out_bytes)

@vectorize
def ApplySecretInverseEmbedding(x):
    in_bytes = x.bit_decompose(40)

    out_bytes = [sgf2n(0) for _ in range(8)]

    out_bytes[7] = in_bytes[7]
    out_bytes[6] = in_bytes[6] + out_bytes[7]
    out_bytes[5] = in_bytes[5] + out_bytes[7]
    out_bytes[4] = in_bytes[4] + out_bytes[5] + out_bytes[6] + out_bytes[7]
    out_bytes[3] = in_bytes[3] + out_bytes[7]
    out_bytes[2] = in_bytes[2] + out_bytes[3] + out_bytes[6] + out_bytes[7]
    out_bytes[1] = in_bytes[1] +  out_bytes[3] + out_bytes[5] + out_bytes[7]
    out_bytes[0] = in_bytes[0] + sum(out_bytes[1:8])

    return sgf2n.bit_compose(out_bytes)



#print_ln("my mult %s",gf_mul(cgf2n(5),sgf2n(5)).reveal())

#https://blog.quarkslab.com/reversing-a-finite-field-multiplication-optimization.html
def mixColumn(column):
    temp = Array(4,sgf2n)
    kv = Array(2,cgf2n)
    kv[0] = ApplyClearEmbedding(cgf2n(0x2))
    kv[1] = ApplyClearEmbedding(cgf2n(0x3))
    for i in range(4):
        temp[i] = ApplySecretEmbedding(column[i])
    column[0] = ApplySecretInverseEmbedding(temp[0]*kv[0] + temp[1]*kv[1] + temp[2] + temp[3])
    column[1] = ApplySecretInverseEmbedding(temp[1]*kv[0] + temp[2]*kv[1] + temp[3] + temp[0])
    column[2] = ApplySecretInverseEmbedding(temp[2]*kv[0] + temp[3]*kv[1] + temp[0] + temp[1])
    column[3] = ApplySecretInverseEmbedding(temp[3]*kv[0] + temp[0]*kv[1] + temp[1] + temp[2])



def mixColumns(state):
    for i in range(4):
        column = Array(4,sgf2n)
        for j in range(4):
            column[j] = state[i*4+j]
        mixColumn(column)
        for j in range(4):
            state[i*4+j] = column[j]
    print_ln("after mix columns")
    state.print_reveal_nested(end="\n")

#incorect give a bad result --> maybe search either gf_mul with high numbers or the function below
@vectorize
def invMixColumn(column):
    temp = Array(4,sgf2n)
    kv = Array(4,cgf2n)
    kv[0] = ApplyClearEmbedding(cgf2n(0xe))
    kv[1] = ApplyClearEmbedding(cgf2n(0xb))
    kv[2] = ApplyClearEmbedding(cgf2n(0xd))
    kv[3] = ApplyClearEmbedding(cgf2n(0x9))
    for i in range(4):
        temp[i] = ApplySecretEmbedding(column[i])
    
    column[0] = ApplySecretInverseEmbedding(temp[0]*kv[0] ^ temp[1]*kv[1] ^ temp[2]*kv[2] ^ temp[3]*kv[3])
    column[1] = ApplySecretInverseEmbedding(temp[1]*kv[0] ^ temp[2]*kv[1] ^ temp[3]*kv[2] ^ temp[0]*kv[3])
    column[2] = ApplySecretInverseEmbedding(temp[2]*kv[0] ^ temp[3]*kv[1] ^ temp[0]*kv[2] ^ temp[1]*kv[3])
    column[3] = ApplySecretInverseEmbedding(temp[3]*kv[0] ^ temp[0]*kv[1] ^ temp[1]*kv[2] ^ temp[2]*kv[3])


@vectorize
def invMixColumns(state):
    for i in range(4):
        column = Array(4,sgf2n)
        for j in range(4):
            column[j] = state[i*4+j]
        invMixColumn(column)
        for j in range(4):
            state[i*4+j] = column[j]
    print_ln("after inverse mix columns")
    state.print_reveal_nested(end="\n")
"""
@vectorize
def mixColumns(state):
    @for_range_opt([4,4])
    def _whatever(i,j):
        res = boxEvaluation(box. state[i] ^ box.gfMult[(j*4)+1]*state[(i+1*4)] ^ box.gfMult[(j*4)+2]*state[i+2*4] ^ box.gfMult[(j*4)+3]*state[i+3*4]).bit_decompose()[0:8])
        state[i+j*4] = res
    print_ln("after mix columns")
    state.print_reveal_nested(end="\n")


def invMixColumns(state):
    @for_range_opt([4,4])
    def _whatever(i,j):
        res = (box.gfMultInv[j*4]*state[i]) ^ (box.gfMultInv[(j*4)+1]*state[(i+1*4)]) ^ (box.gfMultInv[(j*4)+2]*state[i+2*4]) ^ (box.gfMultInv[(j*4)+3]*state[i+3*4])
        state[i*4+j] = res
    print_ln("after inverse mix columns")
    state.print_reveal_nested(end="\n")
"""

def shiftRows(state):
    @for_range_opt(4)
    def _someother(i):
        ns = rotate(state.get_part(i*4,4),i)
        state.assign_part_vector(ns,i*4)
    print_ln("after shift rows")
    state.print_reveal_nested(end="\n")

def shiftColumns(state):
    @for_range_opt(4)
    def _someother(i):
        t = Array(4,sgf2n)
        for j in range(4):
            t[j] = state[i+4*j]
        ns = rotate(t,i)
        for j in range(4):
            state[i+4*j] = ns[j]
    print_ln("after shift columns")
    state.print_reveal_nested(end="\n")

def invShiftColumns(state):
    @for_range_opt(4)
    def _someother(i):
        t = Array(4,sgf2n)
        for j in range(4):
            t[j] = state[i+4*j]
        ns = rotate(t,-i)
        for j in range(4):
            state[i+4*j] = ns[j]
    print_ln("after inverse shift columns")
    state.print_reveal_nested(end="\n")

def invShiftRows(state):
    @for_range_opt(4)
    def _somewhat(i):
        ns = rotate(state.get_part(i*4,4),-i)
        state.assign_part_vector(ns,i*4)
    print_ln("after inverse shift rows")
    state.print_reveal_nested(end="\n")

def createRoundKey(expandedKey, n):
    na = Array(16,sgf2n)
    @for_range_opt(16)
    def _ohoh(i):
        na[i] = expandedKey[n*16+i]
    return na

# aesRound applies each of the four transformations in order
def aesRound(state, roundKey):
    subBytes(state)
    #shiftRows(state)
    shiftColumns(state)
    mixColumns(state)
    addRoundKey(state, roundKey)

# aesRound applies each of the four transformations in inverse order
def invAesRound(state, roundKey):
    #invShiftRows(state)
    invShiftColumns(state)
    invSubBytes(state)
    addRoundKey(state, roundKey)
    invMixColumns(state)

def aesMain(expandedKey,state, numRounds=14):
    roundKey = createRoundKey(expandedKey, 0)
    print_ln("Add round key for first round of encoding")
    addRoundKey(state,roundKey)
    
    @for_range_opt(numRounds-1)
    def _ok(i):
        print_ln("------------------------------")
        print_ln("block before result")
        state.print_reveal_nested(end="\n")
        roundKey = createRoundKey(expandedKey,i+1)
        print_ln("Round key %s",i+1)
        roundKey.print_reveal_nested(end="\n")
        aesRound(state,roundKey)
        print_ln("block result")
        state.print_reveal_nested(end="\n")
        print_ln("------------------------------")
        globalVars.generated.write(0)
    #last round
    roundKey = createRoundKey(expandedKey,numRounds)
    print_ln("Sub bytes shift and add round key for last round")
    subBytes(state)
    #shiftRows(state)
    shiftColumns(state)
    addRoundKey(state,roundKey)

def aesMainInv(expandedKey,state, numRounds=14):
    roundKey = createRoundKey(expandedKey, numRounds)
    print_ln("Add round key for first round of decoding")
    addRoundKey(state,roundKey)
    @for_range_opt(numRounds-1)
    def _ok(i):
        print_ln("------------------------------")
        print_ln("block before result")
        state.print_reveal_nested(end="\n")
        roundKey = createRoundKey(expandedKey,numRounds-i-1)
        print_ln("Round key %s",numRounds-i-1+1)
        roundKey.print_reveal_nested(end="\n")
        invAesRound(state,roundKey)
        print_ln("block inverse result")
        state.print_reveal_nested(end="\n")
        print_ln("------------------------------")
        globalVars.generated.write(0)
    #last round
    print_ln("shift Sub bytes and add round key for last round")
    invShiftColumns(state)
    invSubBytes(state)
    roundKey = createRoundKey(expandedKey,0)
    addRoundKey(state,roundKey)

secret_key = Array(32,sgf2n)
secret_key.assign_all(sgf2n(0))
for i in range(32):
    secret_key[i] ^= (sgf2n.get_input_from(0))
    secret_key[i] ^= (sgf2n.get_input_from(1))

#ici on fixe la taille de notre message initial à un seul bloc mais quand on ne voudra plus hardcoder on devra utiliser des socket clients
blocs  = [] 
number_of_blocs = 1
@for_range_opt(number_of_blocs)
def _ok(i):
    secret_message = Array.create_from(sgf2n.get_input_from(0,size=16))
    blocs.append(secret_message)

for bloc in blocs:
    print_ln("block plain")
    bloc.print_reveal_nested(end="\n")
    print_ln("------------------------------")
    print_ln("secret key")
    secret_key.print_reveal_nested(end="\n")
    print_ln("------------------------------")
    print_ln("expanded key")
    expandedKey = expandAESKey(secret_key)
    expandedKey.print_reveal_nested(end="\n")
    print_ln("------------------------------")
    """
    aesMain(expandedKey,bloc)
    print_ln("block cyphered")
    bloc.print_reveal_nested(end="\n")
    print_ln("------------------------------")
    """
    aesMainInv(expandedKey,bloc)
    print_ln("block uncyphered")
    bloc.print_reveal_nested(end="\n")
    print_ln("------------------------------")

"""
# performance for Lookup Table : compiling in MlD and executing with batch -b=64
# - compiling : 2min 30 seconds

Default bit length: 64
Default security parameter: 40
Compiling file /home/red/mp-spdz-0.3.2/Programs/Source/bacas.mpc
Compiled 100000 lines at Mon Jul 11 16:38:18 2022
Compiled 200000 lines at Mon Jul 11 16:38:19 2022
Compiled 300000 lines at Mon Jul 11 16:38:21 2022
Compiled 400000 lines at Mon Jul 11 16:38:22 2022
Compiled 500000 lines at Mon Jul 11 16:38:24 2022
Compiled 600000 lines at Mon Jul 11 16:38:25 2022
Compiled 700000 lines at Mon Jul 11 16:38:27 2022
Compiled 800000 lines at Mon Jul 11 16:38:28 2022
Compiled 900000 lines at Mon Jul 11 16:38:30 2022
Compiled 1000000 lines at Mon Jul 11 16:38:31 2022
Compiled 1100000 lines at Mon Jul 11 16:38:33 2022
Compiled 1200000 lines at Mon Jul 11 16:38:35 2022
Compiled 1300000 lines at Mon Jul 11 16:38:36 2022
Compiled 1400000 lines at Mon Jul 11 16:38:38 2022
Compiled 1500000 lines at Mon Jul 11 16:38:39 2022
Compiled 1600000 lines at Mon Jul 11 16:38:41 2022
Compiled 1700000 lines at Mon Jul 11 16:38:43 2022
Compiled 1800000 lines at Mon Jul 11 16:38:44 2022
Compiled 1900000 lines at Mon Jul 11 16:38:46 2022
Compiled 2000000 lines at Mon Jul 11 16:38:47 2022
Compiled 2100000 lines at Mon Jul 11 16:38:50 2022
Compiled 2200000 lines at Mon Jul 11 16:38:51 2022
Compiled 2300000 lines at Mon Jul 11 16:38:52 2022
Compiled 2400000 lines at Mon Jul 11 16:38:53 2022
Compiled 2500000 lines at Mon Jul 11 16:38:55 2022
Compiled 2600000 lines at Mon Jul 11 16:38:58 2022
Compiled 2700000 lines at Mon Jul 11 16:38:59 2022
Writing to /home/red/mp-spdz-0.3.2/Programs/Schedules/bacas.sch
Writing to /home/red/mp-spdz-0.3.2/Programs/Bytecode/bacas-0.bc
Program requires at most:
          32 gf2n inputs from player 1
         880 gf2n inputs from player 0
     1232640 gf2n bits
      608832 gf2n triples
         inf virtual machine rounds

protocol mascot : 

block plain
0x6b0xc10xbe0xe20x2e0x400x9f0x960xe90x3d0x7e0x110x730x930x170x2a
------------------------------
secret key
0x600x3d0xeb0x100x150xca0x710xbe0x2b0x730xae0xf00x850x7d0x770x810x1f0x350x2c0x70x3b0x610x80xd70x2d0x980x100xa30x90x140xdf0xf4


# - preprocessing for taking values (message from 0 and key from 1) + expand key  : 1s / negilgeable --> need to take more precise measurment

#  :  negilgeable --> need to take more precise measurment
expanded key
0x600x3d0xeb0x100x150xca0x710xbe0x2b0x730xae0xf00x850x7d0x770x810x1f0x350x2c0x70x3b0x610x80xd70x2d0x980x100xa30x90x140xdf0xf40x9b0xa30x540x110x8e0x690x250xaf0xa50x1a0x8b0x5f0x200x670xfc0xde0xa80xb00x9c0x1a0x930xd10x940xcd0xbe0x490x840x6e0xb70x5d0x5b0x9a0xd50x9a0xec0xb80x5b0xf30xc90x170xfe0xe90x420x480xde0x8e0xbe0x960xb50xa90x320x8a0x260x780xa60x470x980x310x220x290x2f0x6c0x790xb30x810x2c0x810xad0xda0xdf0x480xba0x240x360xa0xf20xfa0xb80xb40x640x980xc50xbf0xc90xbe0xbd0x190x8e0x260x8c0x3b0xa70x90xe00x420x140x6800x7b0xac0xb20xdf0x330x160x960xe90x390xe40x6c0x510x8d0x800xc80x140xe20x40x760xa90xfb0x8a0x500x250xc00x2d0x590xc50x820x390xde0x130x690x670x6c0xcc0x5a0x710xfa0x250x630x950x960x740xee0x150x580x860xca0x5d0x2e0x2f0x310xd70x7e0xa0xf10xfa0x270xcf0x730xc30x740x9c0x470xab0x180x500x1d0xda0xe20x750x7e0x4f0x740x10x900x5a0xca0xfa0xaa0xe30xe40xd50x9b0x340x9a0xdf0x6a0xce0xbd0x100x190xd0xfe0x480x900xd10xe60x180x8d0xb0x40x6d0xf30x440x700x6c0x630x1e

# - cipher all 14 rounds : 12,02 seconds
block cyphered
0xf30xee0xd10xbd0xb50xd20xa00x3c0x60x4b0x5a0x7e0x3d0xb10x810xf8
--> detail 1 block and each function in time

# - uncipher all 14 rounds : 22,87 seconds
block uncyphered
0x6b0xc10xbe0xe20x2e0x400x9f0x960xe90x3d0x7e0x110x730x930x170x2

# data sent 
The following timing is inclusive preprocessing.
Time = 34.3729 seconds 
Data sent = 9060.39 MB in ~432693 rounds (party 0)
Global data sent = 18120.8 MB (all parties


protocol spdz2k :

block plain
0x6b0xc10xbe0xe20x2e0x400x9f0x960xe90x3d0x7e0x110x730x930x170x2a
------------------------------
secret key
0x600x3d0xeb0x100x150xca0x710xbe0x2b0x730xae0xf00x850x7d0x770x810x1f0x350x2c0x70x3b0x610x80xd70x2d0x980x100xa30x90x140xdf0xf4


# - preprocessing for taking values (message from 0 and key from 1) + expand key  : 1s / negilgeable --> need to take more precise measurment

expanded key
0x600x3d0xeb0x100x150xca0x710xbe0x2b0x730xae0xf00x850x7d0x770x810x1f0x350x2c0x70x3b0x610x80xd70x2d0x980x100xa30x90x140xdf0xf40x9b0xa30x540x110x8e0x690x250xaf0xa50x1a0x8b0x5f0x200x670xfc0xde0xa80xb00x9c0x1a0x930xd10x940xcd0xbe0x490x840x6e0xb70x5d0x5b0x9a0xd50x9a0xec0xb80x5b0xf30xc90x170xfe0xe90x420x480xde0x8e0xbe0x960xb50xa90x320x8a0x260x780xa60x470x980x310x220x290x2f0x6c0x790xb30x810x2c0x810xad0xda0xdf0x480xba0x240x360xa0xf20xfa0xb80xb40x640x980xc50xbf0xc90xbe0xbd0x190x8e0x260x8c0x3b0xa70x90xe00x420x140x6800x7b0xac0xb20xdf0x330x160x960xe90x390xe40x6c0x510x8d0x800xc80x140xe20x40x760xa90xfb0x8a0x500x250xc00x2d0x590xc50x820x390xde0x130x690x670x6c0xcc0x5a0x710xfa0x250x630x950x960x740xee0x150x580x860xca0x5d0x2e0x2f0x310xd70x7e0xa0xf10xfa0x270xcf0x730xc30x740x9c0x470xab0x180x500x1d0xda0xe20x750x7e0x4f0x740x10x900x5a0xca0xfa0xaa0xe30xe40xd50x9b0x340x9a0xdf0x6a0xce0xbd0x100x190xd0xfe0x480x900xd10xe60x180x8d0xb0x40x6d0xf30x440x700x6c0x630x1e

# - cipher all 14 rounds : 11,60 seconds
block cyphered
0xf30xee0xd10xbd0xb50xd20xa00x3c0x60x4b0x5a0x7e0x3d0xb10x810xf8
--> detail 1 block and each function in time

# - uncipher all 14 rounds : 21,40 seconds
block uncyphered
0x6b0xc10xbe0xe20x2e0x400x9f0x960xe90x3d0x7e0x110x730x930x170x2

The following timing is inclusive preprocessing.
Time = 32.5342 seconds 
Data sent = 9060.39 MB in ~432697 rounds (party 0)
Global data sent = 18120.8 MB (all parties)


protocol semi2k :

block plain
0x6b0xc10xbe0xe20x2e0x400x9f0x960xe90x3d0x7e0x110x730x930x170x2a
------------------------------
secret key
0x600x3d0xeb0x100x150xca0x710xbe0x2b0x730xae0xf00x850x7d0x770x810x1f0x350x2c0x70x3b0x610x80xd70x2d0x980x100xa30x90x140xdf0xf4


# - preprocessing for taking values (message from 0 and key from 1) + expand key  : 1s / negilgeable --> need to take more precise measurment

expanded key
0x600x3d0xeb0x100x150xca0x710xbe0x2b0x730xae0xf00x850x7d0x770x810x1f0x350x2c0x70x3b0x610x80xd70x2d0x980x100xa30x90x140xdf0xf40x9b0xa30x540x110x8e0x690x250xaf0xa50x1a0x8b0x5f0x200x670xfc0xde0xa80xb00x9c0x1a0x930xd10x940xcd0xbe0x490x840x6e0xb70x5d0x5b0x9a0xd50x9a0xec0xb80x5b0xf30xc90x170xfe0xe90x420x480xde0x8e0xbe0x960xb50xa90x320x8a0x260x780xa60x470x980x310x220x290x2f0x6c0x790xb30x810x2c0x810xad0xda0xdf0x480xba0x240x360xa0xf20xfa0xb80xb40x640x980xc50xbf0xc90xbe0xbd0x190x8e0x260x8c0x3b0xa70x90xe00x420x140x6800x7b0xac0xb20xdf0x330x160x960xe90x390xe40x6c0x510x8d0x800xc80x140xe20x40x760xa90xfb0x8a0x500x250xc00x2d0x590xc50x820x390xde0x130x690x670x6c0xcc0x5a0x710xfa0x250x630x950x960x740xee0x150x580x860xca0x5d0x2e0x2f0x310xd70x7e0xa0xf10xfa0x270xcf0x730xc30x740x9c0x470xab0x180x500x1d0xda0xe20x750x7e0x4f0x740x10x900x5a0xca0xfa0xaa0xe30xe40xd50x9b0x340x9a0xdf0x6a0xce0xbd0x100x190xd0xfe0x480x900xd10xe60x180x8d0xb0x40x6d0xf30x440x700x6c0x630x1e

# - cipher all 14 rounds : 2,66 seconds
block cyphered
0xf30xee0xd10xbd0xb50xd20xa00x3c0x60x4b0x5a0x7e0x3d0xb10x810xf8
--> detail 1 block and each function in time

# - uncipher all 14 rounds : 4,21 seconds
block uncyphered
0x6b0xc10xbe0xe20x2e0x400x9f0x960xe90x3d0x7e0x110x730x930x170x2

The following timing is inclusive preprocessing.
Time = 6.68608 seconds 
Data sent = 1663.02 MB in ~214745 rounds (party 0)
Global data sent = 3326.04 MB (all parties)
"""
#print_ln(" my value of obox %s",box.obox[sgf2n(0)].reveal())


"""
#before inv MC : 39331d51b410a096f0cf923bd833e3b5
stateMC = [sgf2n(0x39),sgf2n(0x33),sgf2n(0x1d),sgf2n(0x51),sgf2n(0xb4),sgf2n(0x10),sgf2n(0xa0),sgf2n(0x96),sgf2n(0xf0),sgf2n(0xcf),sgf2n(0x92),sgf2n(0x3b),sgf2n(0xd8),sgf2n(0x33),sgf2n(0xe3),sgf2n(0x5)]
stateMC = Array.create_from(stateMC)
print_ln("before inverse mix columns")
stateMC.print_reveal_nested(end="\n")
invMixColumns(stateMC)
#after inv MC : fdbc5552d92bf29257c20201db848163
"""

"""
block.print_reveal_nested(end="\n")
print_ln("----------")
"""